1.OOP

（1）继承（2）封装（3）多态

2.访问修饰符限制

public>protected>default>private

3.重载与重写

重载（overloading）
  （1） 方法重载是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，具有不同的参数个数/类型。
重载Overloading是一个类中多态性的一种表现。
  （2） Java的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但具有不同的参数和不同的定义。
调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是多态性。
  （3） 重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准。
  
  【统一方式处理不同类型数据，方法名相同，参数个数、类型，方法返回值不同】
  
重写（overridding）
   （1） 父类与子类之间的多态性，对父类的函数进行重新定义。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。
   （2）若子类中的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法将覆盖原有的方法。
如需父类中原有的方法，可使用super关键字，该关键字引用了当前类的父类。
   （3）子类函数的访问修饰权限不能少于父类的。
   
   【重写只能存在继承关系中，重写方法只能重写父类的非私有方法，多态性】
  
4.关于使用内部类

其实也就是一个类中还包含着另外一个类，如同一个人是由大脑、肢体、器官等身体结果组成，而内部类相当于其中的某个器官之一
例如心脏：它也有自己的属性和行为（血液、跳动）

class Out {
    private int age = 12;
     
    class In {
        private int age = 13;
        public void print() {
            int age = 14;
            System.out.println("局部变量：" + age);//14
            System.out.println("内部类变量：" + this.age);//13
            System.out.println("外部类变量：" + Out.this.age);//12
        }
    }
}
 
public class Demo {
    public static void main(String[] args) {
        Out.In in = new Out().new In();
        in.print();
    }
}

（1）内部类在没有同名成员变量和局部变量的情况下，内部类会直接访问外部类的成员变量，而无需指定Out.this.属性名，否则，内部类中的局部变量会覆盖外部
类的成员变量，而访问内部类本身的成员变量可用this.属性名，访问外部类的成员变量需要使用Out.this.属性名。
（2）如果用static 将内部内静态化，那么内部类就只能访问外部类的静态成员变量，具有局限性
（3）如果一个内部类只希望被外部类中的方法操作，那么可以使用private声明内部类

5.String、StringBuffer、StringBuilder之间区别
   
   （1）三者在执行速度方面的比较：StringBuilder >  StringBuffer  >  String
    String str = “This is only a”（str1） + “ simple”（str2） + “ test”（str3）;
    StringBuffer builder = new StringBuilder(“This is only a”).append(“ simple”).append(“ test”);
   
   【每当用String操作字符串时，实际上是在不断的创建新的对象，而原来的对象就会变为垃圾被ＧＣ回收掉、而StringBuffer与StringBuilder就不一样了，
   他们是字符串变量，是可改变的对象，每当我们用它们对字符串做操作时，实际上是在一个对象上操作的】
   
   （2）StringBuffer是线程安全的，StringBuilder是线程非安全的
   
   【当我们在字符串缓冲去被多个线程使用是，JVM不能保证StringBuilder的操作是安全的，虽然他的速度最快，但是可以保证StringBuffer是可以正确操作的。
   当然大多数情况下就是我们是在单线程下进行的操作，所以大多数情况下是建议用StringBuilder而不用StringBuffer的，就是速度的原因。】
   
   （3）操作少量数据用String、单线程字符串缓冲区大量数据StringBuilder、多线程字符串缓冲区大量数据StringBuffer
   
