1.OOP

（1）继承（2）封装（3）多态

2.访问修饰符限制

public>protected>default>private

3.重载与重写

重载（overloading）
  （1） 方法重载是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，具有不同的参数个数/类型。
重载Overloading是一个类中多态性的一种表现。
  （2） Java的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但具有不同的参数和不同的定义。
调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是多态性。
  （3） 重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准。
  
  【统一方式处理不同类型数据，方法名相同，参数个数、类型，方法返回值不同】
  
重写（overridding）
   （1） 父类与子类之间的多态性，对父类的函数进行重新定义。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。
   （2）若子类中的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法将覆盖原有的方法。
如需父类中原有的方法，可使用super关键字，该关键字引用了当前类的父类。
   （3）子类函数的访问修饰权限不能少于父类的。
   
   【重写只能存在继承关系中，重写方法只能重写父类的非私有方法，多态性】
  
4.关于使用内部类

其实也就是一个类中还包含着另外一个类，如同一个人是由大脑、肢体、器官等身体结果组成，而内部类相当于其中的某个器官之一
例如心脏：它也有自己的属性和行为（血液、跳动）

class Out {
    private int age = 12;
     
    class In {
        private int age = 13;
        public void print() {
            int age = 14;
            System.out.println("局部变量：" + age);//14
            System.out.println("内部类变量：" + this.age);//13
            System.out.println("外部类变量：" + Out.this.age);//12
        }
    }
}
 
public class Demo {
    public static void main(String[] args) {
        Out.In in = new Out().new In();
        in.print();
    }
}

（1）内部类在没有同名成员变量和局部变量的情况下，内部类会直接访问外部类的成员变量，而无需指定Out.this.属性名，否则，内部类中的局部变量会覆盖外部
类的成员变量，而访问内部类本身的成员变量可用this.属性名，访问外部类的成员变量需要使用Out.this.属性名。
（2）如果用static 将内部内静态化，那么内部类就只能访问外部类的静态成员变量，具有局限性
（3）如果一个内部类只希望被外部类中的方法操作，那么可以使用private声明内部类

5.String、StringBuffer、StringBuilder之间区别
   
   （1）三者在执行速度方面的比较：StringBuilder >  StringBuffer  >  String
    String str = “This is only a”（str1） + “ simple”（str2） + “ test”（str3）;
    StringBuffer builder = new StringBuilder(“This is only a”).append(“ simple”).append(“ test”);
   
   【每当用String操作字符串时，实际上是在不断的创建新的对象，而原来的对象就会变为垃圾被ＧＣ回收掉、而StringBuffer与StringBuilder就不一样了，
   他们是字符串变量，是可改变的对象，每当我们用它们对字符串做操作时，实际上是在一个对象上操作的】
   
   （2）StringBuffer是线程安全的，StringBuilder是线程非安全的
   
   【当我们在字符串缓冲去被多个线程使用是，JVM不能保证StringBuilder的操作是安全的，虽然他的速度最快，但是可以保证StringBuffer是可以正确操作的。
   当然大多数情况下就是我们是在单线程下进行的操作，所以大多数情况下是建议用StringBuilder而不用StringBuffer的，就是速度的原因。】
   
   （3）操作少量数据用String、单线程字符串缓冲区大量数据StringBuilder、多线程字符串缓冲区大量数据StringBuffer
   
6.Java基本数据类型

Java一共有8种基本数据类型（原始数据类型）：     
类型     存储要求                范围（包含）            默认值        包装类
整       int 4字节（32位）      -231~ 231-1               0          Integer
数       short 2字节（16位）    -215~215-1                0          Short
类       long 8字节（64位）     -263~263-1                0          Long
型       byte 1字节（8位）      -27~27-1                  0          Byte
浮点     float 4字节（32位）    -3.4e+38 ~ 3.4e+38        0.0f       Float
类型     double 8字节（64位）   -1.7e+308 ~ 1.7e+308      0          Double
字符     char 2字节（16位）     u0000~uFFFF（‘’~‘？’）    ‘0’        Character （0~216-1（65535））  
布尔     boolean 1/8字节（1位） true, false               FALSE      Boolean

7.抽象类与接口总结

1、抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象
2、抽象类要被子类继承，接口要被类实现
3、接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现
4、接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。
5、抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个实现接口的时候，如不能全部实现接口方
法，那么该类也只能为抽象类
6、抽象方法只能申明，不能实现。abstract void abc();不能写成abstract void abc(){}
7、抽象类里可以没有抽象方法
8、如果一个类里有抽象方法，那么这个类只能是抽象类
9、抽象方法要被实现，所以不能是静态的，也不能是私有的
10、接口可继承接口，并可多继承接口，但类只能单根继承   

【抽象类的抽象方法必须被子类全部实现，不然子类也是抽象类；实现接口的时候，如果不能实现接口所有的方法，该子类也是抽象类；接口只能方法申明，抽象类可以
方法申明，也可以方法实现】

9.不使用第三变量实现数值交换
（1）算术运算
简单来说，就是通过普通的+和-运算来实现。代码如下：
      int a,b;
      a=10;b=12;
      a=b-a; //a=2;b=12
      b=b-a; //a=2;b=10
      a=b+a; //a=10;b=10
（2）位运算
通过异或运算也能实现变量的交换，这也许是最为神奇的，请看以下代码：
      int a=10,b=12; //a=1010^b=1100;
      a=a^b; //a=0110^b=1100;
      b=a^b; //a=0110^b=1010;
      a=a^b; //a=1100=12;b=1010;
【此算法能够实现是由异或运算的特点决定的，通过异或运算能够使数据中的某些位翻转，其他位不变。这就意味着任意一个数与任意一个给定的值连续异或两次，
 值不变】
 
 10.Java类加载器工作原理
 
 是什么？
 类加载器是一个用来加载类文件的类。
 
 Java运行过程是什么？
 Java源代码通过javac编译器编译成类文件，然后类加载器负责加载文件系统、网络或其他来源的类文件,JVM来执行类文件中的字节码来执行程序。
 
 类加载器种类？
 （1）Bootstrap类加载器 – JRE/lib/rt.jar，它是所有类加载器的父加载器
 （2）Extension类加载器 – JRE/lib/ext或者java.ext.dirs指向的目录
 （3）Application/System类加载器 – CLASSPATH环境变量, 由-classpath或-cp选项定义,或者是JAR中的Manifest的classpath属性定义
 
 Java类加载器的作用就是在运行时加载类
 
 Java类加载器基于三个机制：委托、可见性和单一性
 （1）委托是指将加载一个类的请求交给父类加载器
 （2）可见性的原理是子类的加载器可以看见所有的父类加载器加载的类，而父类加载器看不到子类加载器加载的类，有上到下加载，由下到上可见
 （3）单一性原理是指仅加载一个类一次
 
 【classpath定义的是类文件的加载目录，而PATH是定义的是如javac，java等可执行程序的执行路径】
